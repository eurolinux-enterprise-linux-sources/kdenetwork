Index: talk/p2p/base/sessionmanager.cc
===================================================================
--- talk/p2p/base/sessionmanager.cc	(revision 1053219)
+++ talk/p2p/base/sessionmanager.cc	(revision 1053220)
@@ -197,6 +197,7 @@
       // If we haven't rejected, and we haven't selected a transport yet,
       // let's do it now.
       if ((session->state() != Session::STATE_SENTREJECT) &&
+          (session->state() != Session::STATE_SENTTERMINATE) &&
           (session->transport() == NULL)) {
         session->ChooseTransport(stanza);
       }
Index: talk/p2p/client/sessionsendtask.h
===================================================================
--- talk/p2p/client/sessionsendtask.h	(revision 1053219)
+++ talk/p2p/client/sessionsendtask.h	(revision 1053220)
@@ -34,6 +34,7 @@
 #include "talk/xmpp/xmppengine.h"
 #include "talk/xmpp/xmpptask.h"
 #include "talk/p2p/base/sessionmanager.h"
+#include "talk/base/logging.h"
 
 namespace cricket {
 
@@ -76,6 +77,7 @@
     } else {
       stanza_->SetAttr(buzz::QN_ID, task_id());
     }
+    LOG(LS_VERBOSE) << "sending stanza\n" << stanza_.get()->BodyText().c_str() << "\n"; 
   }
 
   sigslot::signal1<SessionSendTask *> SignalDone;
Index: talk/p2p/client/sessionmanagertask.h
===================================================================
--- talk/p2p/client/sessionmanagertask.h	(revision 1053219)
+++ talk/p2p/client/sessionmanagertask.h	(revision 1053220)
@@ -32,6 +32,7 @@
 #include "talk/p2p/client/sessionsendtask.h"
 #include "talk/xmpp/xmppengine.h"
 #include "talk/xmpp/xmpptask.h"
+#include "talk/base/logging.h"
 
 namespace cricket {
 
@@ -66,6 +67,7 @@
 
  protected:
   virtual bool HandleStanza(const buzz::XmlElement *stanza) {
+    LOG(LS_VERBOSE) << "HandleStanza()\n" << stanza->BodyText().c_str() << "\n";
     if (!session_manager_->IsSessionMessage(stanza))
       return false;
     // Responses are handled by the SessionSendTask that sent the request.
Index: talk/session/fileshare/fileshare.cc
===================================================================
--- talk/session/fileshare/fileshare.cc	(revision 1053219)
+++ talk/session/fileshare/fileshare.cc	(revision 1053220)
@@ -1080,6 +1080,7 @@
   } else {
     talk_base::FileStream* file = new talk_base::FileStream;
     if (!file->Open(temp_name.pathname().c_str(), "wb")) {
+      std::cout << "Failed to create file at " << temp_name.pathname().c_str() << std::endl;
       delete file;
       talk_base::Filesystem::DeleteFile(temp_name);
       SetState(FS_FAILURE, false);
Index: talk/session/phone/voicechannel.cc
===================================================================
--- talk/session/phone/voicechannel.cc	(revision 1053219)
+++ talk/session/phone/voicechannel.cc	(revision 1053220)
@@ -94,6 +94,14 @@
   case MSG_SETSENDCODEC:
     SetSendCodec_w();
     break;
+
+  case MSG_STARTRING_INCOMING:
+    StartRing_w(true);
+    break;
+
+  case MSG_STARTRING_OUTGOING:
+    StartRing_w(false);
+    break;
   }
 }
 
@@ -115,9 +123,15 @@
 
 void VoiceChannel::OnSessionState(Session* session, Session::State state) {
   if ((state == Session::STATE_RECEIVEDACCEPT) ||
-      (state == Session::STATE_RECEIVEDINITIATE)) {
+      (state == Session::STATE_SENTACCEPT)) {
     channel_manager_->worker_thread()->Post(this, MSG_SETSENDCODEC);
   }
+  if (state == Session::STATE_RECEIVEDINITIATE) {
+    channel_manager_->worker_thread()->Post(this, MSG_STARTRING_INCOMING);
+  }
+  if (state == Session::STATE_SENTINITIATE) {
+    channel_manager_->worker_thread()->Post(this, MSG_STARTRING_OUTGOING);
+  }
 }
 
 void VoiceChannel::SetSendCodec_w() {
@@ -130,6 +144,12 @@
   media_channel_->SetCodecs(desc->codecs());
 }
 
+void VoiceChannel::StartRing_w(bool bIncomingCall) {
+  assert(channel_manager_->worker_thread() == talk_base::Thread::Current());
+
+  media_channel_->StartRing(bIncomingCall);
+}
+
 void VoiceChannel::OnWritableState(TransportChannel* channel) {
   ASSERT(channel == transport_channel_);
   if (transport_channel_->writable()) {
Index: talk/session/phone/voicechannel.h
===================================================================
--- talk/session/phone/voicechannel.h	(revision 1053219)
+++ talk/session/phone/voicechannel.h	(revision 1053220)
@@ -44,6 +44,9 @@
 const uint32 MSG_MUTE = 3;
 const uint32 MSG_UNMUTE = 4;
 const uint32 MSG_SETSENDCODEC = 5;
+const uint32 MSG_STARTRING_INCOMING = 6;
+const uint32 MSG_STARTRING_OUTGOING = 7;
+const uint32 MSG_STOPRING = 8;
 
 
 class ChannelManager;
@@ -113,6 +116,7 @@
   // Setting the send codec based on the remote description.
   void OnSessionState(Session* session, Session::State state);
   void SetSendCodec_w();
+  void StartRing_w(bool bIncomingCall);
 
   // From TransportChannel
 
Index: talk/session/phone/linphonemediaengine.cc
===================================================================
--- talk/session/phone/linphonemediaengine.cc	(revision 1053219)
+++ talk/session/phone/linphonemediaengine.cc	(revision 1053220)
@@ -23,14 +23,17 @@
 
 // LinphoneMediaEngine is a Linphone implementation of MediaEngine
 extern "C" {
-#include "talk/third_party/mediastreamer/mediastream.h"
-#ifdef HAVE_ILBC
-#include "talk/third_party/mediastreamer/msilbcdec.h"
-#endif
+#include <mediastreamer2/mediastream.h>
+#include <mediastreamer2/mssndcard.h>
+//#ifdef HAVE_ILBC
+//#include "talk/third_party/mediastreamer/msilbcdec.h"
+//#endif
 #ifdef HAVE_SPEEX
-#include "talk/third_party/mediastreamer/msspeexdec.h"
+#include <mediastreamer2/msfilter.h>
 #endif
 }
+
+#include <glib-2.0/glib.h>
 #include <ortp/ortp.h>
 #include <ortp/telephonyevents.h>
 #include <netdb.h>
@@ -56,7 +59,9 @@
 LinphoneMediaChannel::LinphoneMediaChannel(LinphoneMediaEngine*eng) :
   pt_(-1),
   audio_stream_(0),
-  engine_(eng) {
+  engine_(eng), 
+  ring_stream_(0)
+ {
   
   talk_base::Thread *thread = talk_base::ThreadManager::CurrentThread();
   talk_base::SocketServer *ss = thread->socketserver();
@@ -67,14 +72,56 @@
 }
 
 LinphoneMediaChannel::~LinphoneMediaChannel() {
-  if (audio_stream_ != 0)
-    audio_stream_stop(audio_stream_);
+
+
+  //bjd
+  fflush(stdout);
+  StopRing();
+
+  if (audio_stream_)
+      audio_stream_stop(audio_stream_);
 }
 
+void LinphoneMediaChannel::StartRing(bool bIncomingCall)
+{
+  MSSndCard *sndcard = NULL;
+  sndcard=ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());
+  if (sndcard)
+  {
+    if (bIncomingCall)
+    {
+      if (engine_->GetRingWav().size() > 0)
+      {
+		 LOG(LS_VERBOSE) << "incoming ring. sound file: " << engine_->GetRingWav().c_str() << "\n";
+	     ring_stream_ = ring_start (engine_->GetRingWav().c_str(), 1, sndcard);
+      }
+    }
+    else
+    {
+      if (engine_->GetCallWav().size() > 0)
+      {
+		LOG(LS_VERBOSE) << "outgoing ring. sound file: " << engine_->GetCallWav().c_str() << "\n";  
+	    ring_stream_ = ring_start (engine_->GetCallWav().c_str(), 1, sndcard);
+      }
+    }
+  }
+}
+
+void LinphoneMediaChannel::StopRing()
+{
+	if (ring_stream_) { 
+		ring_stop(ring_stream_);
+		ring_stream_ = 0;
+	}
+}
+
+
 void LinphoneMediaChannel::SetCodecs(const std::vector<Codec> &codecs) {
  bool first = true;
  std::vector<Codec>::const_iterator i;
 
+  ortp_set_log_level_mask(ORTP_MESSAGE|ORTP_WARNING|ORTP_ERROR|ORTP_FATAL);
+
   for (i = codecs.begin(); i < codecs.end(); i++) {
 
     if (!engine_->FindCodec(*i))
@@ -95,23 +142,25 @@
     if (i->id == 0)
       rtp_profile_set_payload(&av_profile, 0, &payload_type_pcmu8000);
 
-/*    if (i->name == telephone_event.mime_type) {
-      rtp_profile_set_payload(&av_profile, i->id, &telephone_event);
-    }*/
+    if (i->name == payload_type_telephone_event.mime_type) {
+      rtp_profile_set_payload(&av_profile, i->id, &payload_type_telephone_event);
+    }
     
     if (first) {
+      StopRing();
       LOG(LS_INFO) << "Using " << i->name << "/" << i->clockrate;
       pt_ = i->id;
-      audio_stream_ = audio_stream_start(&av_profile, 2000, "127.0.0.1", 3000, i->id, 250);
+      audio_stream_ = audio_stream_start(&av_profile, 2000, "127.0.0.1", 3000, i->id, 250, 0);
       first = false;
     }
   }
   
   if (first) {
+    StopRing();
     // We're being asked to set an empty list of codecs. This will only happen when
     // working with a buggy client; let's try PCMU.
-     LOG(LS_WARNING) << "Received empty list of codces; using PCMU/8000";
-    audio_stream_ = audio_stream_start(&av_profile, 2000, "127.0.0.1", 3000, 0, 250);
+    LOG(LS_WARNING) << "Received empty list of codces; using PCMU/8000";
+    audio_stream_ = audio_stream_start(&av_profile, 2000, "127.0.0.1", 3000, 0, 250, 0);
   }
  
 }
@@ -119,8 +168,8 @@
 bool LinphoneMediaEngine::FindCodec(const Codec &c) {
   if (c.id == 0)
     return true;
-/*  if (c.name == telephone_event.mime_type)
-    return true;*/
+  if (c.name == payload_type_telephone_event.mime_type)
+    return true;
 #ifdef HAVE_SPEEX
   if (c.name == payload_type_speex_wb.mime_type && c.clockrate == payload_type_speex_wb.clock_rate)
     return true;
@@ -156,7 +205,12 @@
 
 int LinphoneMediaChannel::GetOutputLevel() {}
 
-LinphoneMediaEngine::LinphoneMediaEngine() {}
+LinphoneMediaEngine::LinphoneMediaEngine(const std::string& ringWav,  const std::string& callWav)
+    : ring_wav_(ringWav),
+      call_wav_(callWav)
+{
+}
+
 LinphoneMediaEngine::~LinphoneMediaEngine() {}
 
 static void null_log_handler(const gchar *log_domain,
@@ -174,7 +228,8 @@
   ms_init();
  
 #ifdef HAVE_SPEEX
-  ms_speex_codec_init();
+  //ms_speex_codec_init();
+  //ms_filter_register(MS_FILTER_INFO(&speex_info));
 
   codecs_.push_back(Codec(110, payload_type_speex_wb.mime_type, payload_type_speex_wb.clock_rate, 0, 1, 8));
   codecs_.push_back(Codec(111, payload_type_speex_nb.mime_type, payload_type_speex_nb.clock_rate, 0, 1, 7));
@@ -182,17 +237,17 @@
 #endif
 
 #ifdef HAVE_ILBC
-  ms_ilbc_codec_init();
+  //ms_ilbc_codec_init();
   codecs_.push_back(Codec(102, payload_type_ilbc.mime_type, payload_type_ilbc.clock_rate, 0, 1, 4));
 #endif
 
   codecs_.push_back(Codec(0, payload_type_pcmu8000.mime_type, payload_type_pcmu8000.clock_rate, 0, 1, 2));
- // codecs_.push_back(Codec(101, telephone_event.mime_type, telephone_event.clock_rate, 0, 1, 1));
+  codecs_.push_back(Codec(101, payload_type_telephone_event.mime_type, payload_type_telephone_event.clock_rate, 0, 1, 1));
   return true;
 }
 
 void LinphoneMediaEngine::Terminate() {
- 
+  fflush(stdout);
 }
   
 MediaChannel *LinphoneMediaEngine::CreateChannel() {
Index: talk/session/phone/channelmanager.cc
===================================================================
--- talk/session/phone/channelmanager.cc	(revision 1053219)
+++ talk/session/phone/channelmanager.cc	(revision 1053220)
@@ -45,13 +45,14 @@
 const uint32 MSG_DESTROYVOICECHANNEL = 2;
 const uint32 MSG_SETAUDIOOPTIONS = 3;
 
-ChannelManager::ChannelManager(talk_base::Thread *worker_thread) {
+ChannelManager::ChannelManager(talk_base::Thread *worker_thread, 
+                               const std::string& ringWav, const std::string& callWav) {
 #ifdef HAVE_GIPS
   media_engine_ = new GipsMediaEngine();
 #elif HAVE_GIPSLITE
   media_engine_ = new GipsLiteMediaEngine();
 #else
-  media_engine_ = new LinphoneMediaEngine();
+  media_engine_ = new LinphoneMediaEngine(ringWav, callWav);
 #endif
   worker_thread_ = worker_thread;
   initialized_ = false;
Index: talk/session/phone/linphonemediaengine.h
===================================================================
--- talk/session/phone/linphonemediaengine.h	(revision 1053219)
+++ talk/session/phone/linphonemediaengine.h	(revision 1053220)
@@ -23,7 +23,7 @@
 #define TALK_SESSION_PHONE_LINPHONEMEDIAENGINE_H_
 
 extern "C" {
-#include "talk/third_party/mediastreamer/mediastream.h"
+#include <mediastreamer2/mediastream.h>
 }
 #include "talk/base/asyncsocket.h"
 #include "talk/base/scoped_ptr.h"
@@ -40,6 +40,8 @@
 
   virtual void SetCodecs(const std::vector<Codec> &codecs);
   virtual void OnPacketReceived(const void *data, int len);
+  virtual void StartRing(bool bIncomingCall);
+  virtual void StopRing();
 
   virtual void SetPlayout(bool playout);
   virtual void SetSend(bool send);
@@ -52,6 +54,7 @@
   virtual void StopMediaMonitor() {}
    
  private:
+  RingStream* ring_stream_;
   LinphoneMediaEngine *engine_;
   AudioStream *audio_stream_;
   talk_base::scoped_ptr<talk_base::AsyncSocket> socket_;
@@ -63,7 +66,7 @@
 
 class LinphoneMediaEngine : public MediaEngine {
  public:
-  LinphoneMediaEngine();
+  LinphoneMediaEngine(const std::string& ringWav,  const std::string& callWav);
   ~LinphoneMediaEngine();
   virtual bool Init();
   virtual void Terminate();
@@ -79,8 +82,14 @@
   virtual std::vector<Codec, std::allocator<Codec> > codecs() {return codecs_;}
   virtual bool FindCodec(const Codec&);
 
+  std::string GetRingWav(){return ring_wav_;}
+  std::string GetCallWav(){return call_wav_;}
+
  private:
   std::vector<Codec, std::allocator<Codec> > codecs_;
+
+  std::string ring_wav_;
+  std::string call_wav_;
 };
 
 }  // namespace cricket
Index: talk/session/phone/channelmanager.h
===================================================================
--- talk/session/phone/channelmanager.h	(revision 1053219)
+++ talk/session/phone/channelmanager.h	(revision 1053220)
@@ -41,7 +41,7 @@
 
 class ChannelManager : public talk_base::MessageHandler {
 public:
-  ChannelManager(talk_base::Thread *worker_thread);
+  ChannelManager(talk_base::Thread *worker_thread, const std::string& ringWav, const std::string& callWav);
   ~ChannelManager();
 
   VoiceChannel *CreateVoiceChannel(Session *session);
Index: talk/session/phone/mediachannel.h
===================================================================
--- talk/session/phone/mediachannel.h	(revision 1053219)
+++ talk/session/phone/mediachannel.h	(revision 1053220)
@@ -58,6 +58,9 @@
   virtual ~MediaChannel() {};
   void SetInterface(NetworkInterface *iface) {network_interface_ = iface;}
   virtual void SetCodecs(const std::vector<Codec> &codecs) = 0;
+  virtual void StartRing(bool bIncomingCall) = 0;
+  virtual void StopRing() = 0;
+
   virtual void OnPacketReceived(const void *data, int len) = 0;
   virtual void SetPlayout(bool playout) = 0;
   virtual void SetSend(bool send) = 0;
Index: talk/session/phone/phonesessionclient.cc
===================================================================
--- talk/session/phone/phonesessionclient.cc	(revision 1053219)
+++ talk/session/phone/phonesessionclient.cc	(revision 1053220)
@@ -25,13 +25,12 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <cstdio>
+
 #include "talk/base/logging.h"
 #include "talk/session/phone/phonesessionclient.h"
 #include "talk/xmpp/constants.h"
 #include "talk/xmllite/qname.h"
-
-#include <stdio.h>
-
 namespace {
 
 const std::string NS_PHONE("http://www.google.com/session/phone");
@@ -49,13 +48,14 @@
 namespace cricket {
 
 PhoneSessionClient::PhoneSessionClient(
-    const buzz::Jid& jid, SessionManager *manager)
+    const buzz::Jid& jid, SessionManager *manager, 
+    const std::string& ringWav, const std::string& callWav)
   : jid_(jid), session_manager_(manager) {
   // No call to start, and certainly no call with focus
   focus_call_ = NULL;
 
   // Start up the channel manager on a worker thread
-  channel_manager_ = new ChannelManager(session_manager_->worker_thread());
+  channel_manager_ = new ChannelManager(session_manager_->worker_thread(), ringWav, callWav);
 
   // Register ourselves as the handler of phone sessions.
   session_manager_->AddClient(NS_PHONE, this);
Index: talk/session/phone/phonesessionclient.h
===================================================================
--- talk/session/phone/phonesessionclient.h	(revision 1053219)
+++ talk/session/phone/phonesessionclient.h	(revision 1053220)
@@ -46,7 +46,8 @@
 
 class PhoneSessionClient: public SessionClient, public sigslot::has_slots<> {
 public:
-  PhoneSessionClient(const buzz::Jid& jid, SessionManager *manager);
+  PhoneSessionClient(const buzz::Jid& jid, SessionManager *manager, 
+                     const std::string& ringWav = "", const std::string& callWav = "");
   ~PhoneSessionClient();
 
   const buzz::Jid &jid() const { return jid_; }
Index: talk/xmpp/xmpplogintask.cc
===================================================================
--- talk/xmpp/xmpplogintask.cc	(revision 1053219)
+++ talk/xmpp/xmpplogintask.cc	(revision 1053220)
@@ -108,6 +108,7 @@
     switch (state_) {
 
       case LOGINSTATE_INIT: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance()  LOGINSTATE_INIT";
         pctx_->RaiseReset();
         pelFeatures_.reset(NULL);
 
@@ -122,17 +123,25 @@
       }
 
       case LOGINSTATE_STREAMSTART_SENT: {
-        if (NULL == (element = NextStanza()))
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance()  LOGINSTATE_STREAMSTART_SENT";  
+        if (NULL == (element = NextStanza())) {
+          LOG(LS_VERBOSE) << "XmppLoginTask::Advance() NextStanza() == NULL";
           return true;
+        }  
 
-        if (!isStart_ || !HandleStartStream(element))
+        if (!isStart_ || !HandleStartStream(element)) {
+          LOG(LS_VERBOSE) << "XmppLoginTask::Advance() !isStart_ || !HandleStartStream(element) == true";
+          LOG(LS_VERBOSE) << "isStart_=" << isStart_;  
           return Failure(XmppEngine::ERROR_VERSION);
+        }  
 
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() state_ = LOGINSTATE_STARTED_XMPP";
         state_ = LOGINSTATE_STARTED_XMPP;
         return true;
       }
 
       case LOGINSTATE_STARTED_XMPP: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance()  LOGINSTATE_STARTED_XMPP";    
         if (NULL == (element = NextStanza()))
           return true;
 
@@ -155,6 +164,7 @@
       }
 
       case LOGINSTATE_TLS_INIT: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance()  LOGINSTATE_TLS_INIT";      
         const XmlElement * pelTls = GetFeature(QN_TLS_STARTTLS);
         if (!pelTls)
           return Failure(XmppEngine::ERROR_TLS);
@@ -166,6 +176,7 @@
       }
 
       case LOGINSTATE_TLS_REQUESTED: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance()  LOGINSTATE_TLS_REQUESTED";  
         if (NULL == (element = NextStanza()))
           return true;
         if (element->Name() != QN_TLS_PROCEED)
@@ -183,6 +194,7 @@
       }
 
       case LOGINSTATE_AUTH_INIT: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_AUTH_INIT";   
         const XmlElement * pelSaslAuth = GetFeature(QN_SASL_MECHANISMS);
         if (!pelSaslAuth) {
           return Failure(XmppEngine::ERROR_AUTH);
@@ -223,6 +235,7 @@
       }
         
       case LOGINSTATE_SASL_RUNNING: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_SASL_RUNNING";      
         if (NULL == (element = NextStanza()))
           return true;
         if (element->Name().Namespace() != NS_SASL)
@@ -251,6 +264,7 @@
       }
 
       case LOGINSTATE_BIND_INIT: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_BIND_INIT";
         const XmlElement * pelBindFeature = GetFeature(QN_BIND_BIND);
         const XmlElement * pelSessionFeature = GetFeature(QN_SESSION_SESSION);
         if (!pelBindFeature || !pelSessionFeature)
@@ -273,6 +287,7 @@
       }
 
       case LOGINSTATE_BIND_REQUESTED: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_BIND_REQUESTED";
         if (NULL == (element = NextStanza()))
           return true;
 
@@ -303,6 +318,7 @@
       }
 
       case LOGINSTATE_SESSION_REQUESTED: {
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_SESSION_REQUESTED";
         if (NULL == (element = NextStanza()))
           return true;
         if (element->Name() != QN_IQ || element->Attr(QN_ID) != iqId_ ||
@@ -319,6 +335,7 @@
       }
 
       case LOGINSTATE_DONE:
+        LOG(LS_VERBOSE) << "XmppLoginTask::Advance() LOGINSTATE_DONE";    
         return false;
     }
   }
@@ -360,6 +377,7 @@
 
 bool
 XmppLoginTask::Failure(XmppEngine::Error reason) {
+  LOG(LS_ERROR) << "XmppLoginTask::Failure() " << reason;
   state_ = LOGINSTATE_DONE;
   pctx_->SignalError(reason, 0);
   return false;
Index: talk/xmpp/xmpptask.cc
===================================================================
--- talk/xmpp/xmpptask.cc	(revision 1053219)
+++ talk/xmpp/xmpptask.cc	(revision 1053220)
@@ -30,6 +30,7 @@
 #include "talk/xmpp/xmppengine.h"
 #include "talk/xmpp/constants.h"
 #include "talk/xmpp/ratelimitmanager.h"
+#include "talk/base/logging.h"
 
 namespace buzz {
 
@@ -90,6 +91,8 @@
     return;
 #endif
 
+  LOG(LS_VERBOSE) << stanza->BodyText().c_str() << "\n";
+  
   stanza_queue_.push_back(new XmlElement(*stanza));
   Wake();
 }
Index: talk/xmpp/xmppclient.cc
===================================================================
--- talk/xmpp/xmppclient.cc	(revision 1053219)
+++ talk/xmpp/xmppclient.cc	(revision 1053220)
@@ -33,6 +33,7 @@
 #include "talk/xmpp/prexmppauth.h"
 #include "talk/base/scoped_ptr.h"
 #include "talk/xmpp/plainsaslhandler.h"
+#include "talk/base/logging.h"
 
 namespace buzz {
 
@@ -337,7 +338,7 @@
   size_t bytes_read;
   for (;;) {
     if (!socket_->Read(bytes, sizeof(bytes), &bytes_read)) {
-      // TODO: deal with error information
+      LOG(LS_WARNING) << "XmppClient::Private::OnSocketRead() socket_->Read() failed";
       return;
     }
 
Index: talk/base/httpcommon.cc
===================================================================
--- talk/base/httpcommon.cc	(revision 1053219)
+++ talk/base/httpcommon.cc	(revision 1053220)
@@ -337,6 +337,8 @@
   if (7 != sscanf(date.c_str(), "%*3s, %d %3s %d %d:%d:%d %5c",
                   &tval.tm_mday, month, &tval.tm_year,
                   &tval.tm_hour, &tval.tm_min, &tval.tm_sec, &zone)) {
+
+    LOG(LS_ERROR) << "HttpDateToSeconds returns false";
     return false;
   }
   switch (toupper(month[2])) {
Index: talk/base/openssladapter.cc
===================================================================
--- talk/base/openssladapter.cc	(revision 1053219)
+++ talk/base/openssladapter.cc	(revision 1053220)
@@ -256,6 +256,7 @@
     return err;
   }
 
+  LOG(LS_VERBOSE) << "OpenSSLAdapter::StartSSL() returns 0";
   return 0;
 }
 
@@ -318,7 +319,12 @@
   ASSERT(state_ == SSL_CONNECTING);
 
   int code = SSL_connect(ssl_);
-  switch (SSL_get_error(ssl_, code)) {
+  int err = SSL_get_error(ssl_, code);
+  if (err != SSL_ERROR_NONE)
+  {
+	LOG(LS_WARNING) << "!!! SSL_connect() returned " << err; 
+  }
+  switch (err) {
   case SSL_ERROR_NONE:
     LOG(LS_INFO) << " -- success";
 
@@ -356,6 +362,7 @@
     return (code != 0) ? code : -1;
   }
 
+  LOG(LS_VERBOSE) << "OpenSSLAdapter::ContinueSSL() returns 0";
   return 0;
 }
 
@@ -774,7 +781,10 @@
 OpenSSLAdapter::SetupSSLContext() {
   SSL_CTX* ctx = SSL_CTX_new(SSLv23_client_method());
   if (ctx == NULL) 
+  {
+	  LOG(LS_ERROR) << "OpenSSLAdapter::SetupSSLContext() error: ctx == NULL";
 	  return NULL;
+  }  
 
   // Add the root cert to the SSL context
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
Index: talk/examples/pcp/pcp_main.cc
===================================================================
--- talk/examples/pcp/pcp_main.cc	(revision 1053219)
+++ talk/examples/pcp/pcp_main.cc	(revision 1053220)
@@ -263,6 +263,9 @@
       if (send_to_jid_.BareEquals(status.jid())) {
 	std::cout << send_to_jid_.Str() << " has signed on." << std::endl;
 	cricket::FileShareSession* share = file_share_session_client_->CreateFileShareSession();
+	std::cout << "Hit enter to send the files" << std::endl;
+	std::string str;
+	std::cin >> str;
 	share->Share(status.jid(), const_cast<cricket::FileShareManifest*>(manifest_));
 	send_to_jid_ = buzz::Jid("");
       }
Index: talk/examples/login/xmppsocket.cc
===================================================================
--- talk/examples/login/xmppsocket.cc	(revision 1053219)
+++ talk/examples/login/xmppsocket.cc	(revision 1053220)
@@ -65,9 +65,17 @@
 }
 
 void XmppSocket::OnWriteEvent(talk_base::AsyncSocket * socket) {
+  std::string str;
+  str.insert(0, buffer_.Data(), buffer_.Length());  
+  LOG(LS_VERBOSE) << "<><><><><><> outgoing message <><><><><><>" <<
+			"\nXmppSocket::OnWriteEvent() buffer: " << str.c_str();
   // Write bytes if there are any
   while (buffer_.Length() != 0) {
     int written = cricket_socket_->Send(buffer_.Data(), buffer_.Length());
+    if (written == -1) {
+      LOG(LS_WARNING) << "XmppSocket::OnWriteEvent() : cricket_socket_->Send() failed. "
+			"cricket_socket_->Send() returns " << written;
+    }	
     if (written > 0) {
       buffer_.Shift(written);
       continue;
@@ -76,6 +84,7 @@
       LOG(LS_ERROR) << "Send error: " << cricket_socket_->GetError();
     return;
   }
+  LOG(LS_VERBOSE) << "XmppSocket::OnWriteEvent() returns";  
 }
 
 void XmppSocket::OnConnectEvent(talk_base::AsyncSocket * socket) {
@@ -113,6 +122,10 @@
 bool XmppSocket::Read(char * data, size_t len, size_t* len_read) {
   int read = cricket_socket_->Recv(data, len);
   if (read > 0) {
+    std::string str;
+    str.insert(0, data, len); 
+    LOG(LS_VERBOSE) << "<><><><><><> incoming message <><><><><><>" <<
+			"\nXmppSocket::Read() buffer: " << str.c_str();
     *len_read = (size_t)read;
     return true;
   }
Index: talk/examples/call/callclient.cc
===================================================================
--- talk/examples/call/callclient.cc	(revision 1053219)
+++ talk/examples/call/callclient.cc	(revision 1053220)
@@ -35,6 +35,14 @@
 #include "talk/examples/login/presenceouttask.h"
 #include "talk/examples/login/jingleinfotask.h"
 
+#ifndef RINGWAV
+#define RINGWAV ""
+#endif
+
+#ifndef CALLWAV
+#define CALLWAV ""
+#endif
+
 namespace {
 
 const char* DescribeStatus(buzz::Status::Show show, const std::string& desc) {
@@ -242,7 +250,7 @@
   jit->Start();
 	  
   phone_client_ = new cricket::PhoneSessionClient(
-      xmpp_client_->jid(),session_manager_);
+      xmpp_client_->jid(),session_manager_, RINGWAV, CALLWAV);
   phone_client_->SignalCallCreate.connect(this, &CallClient::OnCallCreate);
 
   worker_thread_->Start();
